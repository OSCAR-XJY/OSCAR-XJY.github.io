<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #a2fca2; /*bar colour*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #a2fca2, 0 0 5px     #a2fca2; /*shadow colour*/
    }
    .pace .pace-activity {
        border-top-color: #a2fca2;    /*top colour*/
        border-left-color: #a2fca2;    /*left colour*/
    }
</style>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.google.com/css?family=Georgia:300,300italic,400,400italic,700,700italic|Times New Roman:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/F32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/M16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Comparison Sorts," />










<meta name="description" content="DescriptionSorting algorithms are always extremely useful in both computer science and our daily life. Comparison sorts are a kind of sorting algorithms base on comparison operations. Although compari">
<meta name="keywords" content="Comparison Sorts">
<meta property="og:type" content="article">
<meta property="og:title" content="Comparison Sorts">
<meta property="og:url" content="http://yoursite.com/2018/05/18/Comparison Sorts/index.html">
<meta property="og:site_name" content="Oscar&#39;s Programming Blog">
<meta property="og:description" content="DescriptionSorting algorithms are always extremely useful in both computer science and our daily life. Comparison sorts are a kind of sorting algorithms base on comparison operations. Although compari">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-09-20T00:39:53.106Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Comparison Sorts">
<meta name="twitter:description" content="DescriptionSorting algorithms are always extremely useful in both computer science and our daily life. Comparison sorts are a kind of sorting algorithms base on comparison operations. Although compari">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"display":"always","offset":18,"b2t":false,"scrollpercent":false,"onmobile":true,"scroll_to_more":false,"save_scroll":true,"excerpt_description":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"perspectiveRightIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/18/Comparison Sorts/"/>





  <title>Comparison Sorts | Oscar's Programming Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Oscar's Programming Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-cubes"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Comparison Sorts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Jiayun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oscar's Programming Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Comparison Sorts</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-18T23:19:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Sorting-Algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">Sorting Algorithms</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Sorting algorithms are always extremely useful in both computer science and our daily life. Comparison sorts are a kind of sorting algorithms base on comparison operations. Although comparison sorts have some limitations (like cannot perform better than ${\rm O}\left( {n\log n} \right)$ in average or worst cases), they still hold a lot of commendable features in practice, such as allowing sorting of many different datatypes and fine control over how the elements are sorted.<a id="more"></a> For simplicity, we will use an array $arr$ to store all the numbers (now we are only interested in numbers), and a const $n$ to describe the size of the array.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Best</th>
<th style="text-align:center">Average</th>
<th style="text-align:center">Worst</th>
<th style="text-align:center">Memory</th>
<th style="text-align:center">Stable</th>
<th style="text-align:center">In-place</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Bubble</strong></td>
<td style="text-align:center">${\rm O}\left( n \right)$</td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">${\rm O}\left( 1 \right)$</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center"><strong>Selection</strong></td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">${\rm O}\left( 1 \right)$</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center"><strong>Insertion</strong></td>
<td style="text-align:center">${\rm O}\left( n \right)$</td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">${\rm O}\left( 1 \right)$</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center"><strong>Merge</strong></td>
<td style="text-align:center">${\rm O}\left( {n\log n} \right)$</td>
<td style="text-align:center">${\rm O}\left( {n\log n} \right)$</td>
<td style="text-align:center">${\rm O}\left( {n\log n} \right)$</td>
<td style="text-align:center">${\rm O}\left( n \right)$</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center"><strong>Quick</strong></td>
<td style="text-align:center">${\rm O}\left( {n\log n} \right)$</td>
<td style="text-align:center">${\rm O}\left( {n\log n} \right)$</td>
<td style="text-align:center">${\rm O}\left( { {n^2} } \right)$</td>
<td style="text-align:center">4</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
</tr>
</tbody>
</table>
<h1 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h1><p>Bubble sort is one of the simplest sorting algorithms. It bases on the principle that compare all the adjacent elements in the array, if one element is bigger than the one after it, then swap them. So by doing this process (called a pass) once and once again, when finally swap doesn’t occur, we will gain a sorted array. Now let us find out we need to repeat this process how many times. As we can imagine, an element always flows to the next position, until it arrives at correct place (though it may take a few passes). And the larger an elements is, the earlier it will be sorted (sorted in an earlier pass). So those positions at the end of the array will be sorted first, and swap won’t occur at those places any more. Hence, in every pass, we mark the index at which the last swap occurs, and in the next pass, we only need to compare those adjacent elements before the mark. In the worst cases, the mark moves ahead one position one pass, so it takes total $n-1$ passes. But in other cases, it may be hopefully of taking fewer passes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">10</span>;                                                  <span class="comment">//set arr size=10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[n]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        bubble_sort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=n,mark;       <span class="comment">//at first the entire array is not sorted, set len=n</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">                mark=<span class="number">0</span>;                                               <span class="comment">//set mark=0</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)      <span class="comment">//compare adjacent elements before len</span></span><br><span class="line">                        <span class="keyword">if</span>(arr[i<span class="number">-1</span>]&gt;arr[i])&#123;</span><br><span class="line">                                swap(arr[i<span class="number">-1</span>],arr[i]);</span><br><span class="line">                                mark=i;</span><br><span class="line">                        &#125;               <span class="comment">//mark=the index at which last swap occurs</span></span><br><span class="line">                len=mark;                                        <span class="comment">//update len=mark</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(mark!=<span class="number">0</span>);         <span class="comment">//if swap doesn't occur (mark keeps 0), then exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The time complexity of this algorithm in best, average and worst cases are ${\rm O}\left( n \right)$, ${\rm O}\left( { {n^2} } \right)$, ${\rm O}\left( { {n^2} } \right)$ respectively. Thus it is almost impossilbe to apply this method in sorting largre arrays. Meanwhile, in worst cases, Bubble Sort requests ${\rm O}\left( { {n^2} } \right)$ swaps, which causes it slower than other sort algorithms. However, Bubble Sort is a stable algorithm, which means those elements have same value will remain their initially relative orders after we finished sorting. In-place is its another advantage, in other words, it only needs ${\rm O}\left( {\rm{1} } \right) $ auxiliary storage. Generally, Bubble Sort is slower than Selection Sort, let alone Insertion Sort.</p>
<h1 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h1><p>Selection sort bases on a simply idea. At first the array only has unsorted part, no sorted part. We search the smallest entity within the unsorted part (now entire array), then swap it with the entity at the beginning of the unsorted part (now the entity at the first position of the entire array). By doing this, we divided the array into two parts, one part is sorted (the first position of the entire array), the other part is unsorted (the rest of the array). Next, we do these operations again. Find the smallest entity within the newly unsorted part, then swap it with the entity at the beginning of the newly unsorted part (the entity at the the second position of the entire array). By doing that, we extended the sorted part (the first and second positions of the entire array) and reduced the unsorted part. As we can imagine, repeating these operations, and finally we will get an array only consisted by sorted part.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">10</span>;                                                  <span class="comment">//set arr size=10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[n]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        selection_sort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;               <span class="comment">//i=the first index of unsorted part</span></span><br><span class="line">                <span class="keyword">int</span> min=i;<span class="comment">//min=the index of minimal entity (within unsorted part)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                        <span class="keyword">if</span>(arr[j]&lt;arr[min]) min=j;      </span><br><span class="line">                <span class="keyword">if</span>(min!=i) swap(arr[i],arr[min]);<span class="comment">//swap the minimal entity (within </span></span><br><span class="line">        &#125;       <span class="comment">//unsorted part) with the entity at the beginning of unsorted part</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The time complexity of this algorithm in best, average and worst cases are all ${\rm O}\left( { {n^2} } \right)$, since no matter weather the numbers in the array waiting to be processed have ready sorted or not sorted yet, it makes no difference to the behaviors of this algorithm. This also implies to large test cases (many items needed to be sorted), this algorithm is not fast enough. However, we should also recognize this Selection Sort algorithm is an in-place algorithm, and it only needs ${\rm O}\left( {\rm{1} } \right) $ auxiliary storage. Meanwhile, it is not a stable algorithm, as long as we implement it as above, swapping the entities in the array, rather than inserting the smallest entity to proper position and moving all the following entities a position down.</p>
<h1 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h1><p>Insertion sort is another simply sorting algorithm. We divide the array into two parts, sorted part and unsorted part. At first we have only unsorted part. Then we compare the second element with the first one. If the second one is larger than the first one, then we do nothing. If the second one is smaller than the first one, then we move the first element one position down ( to the second position), and put the second element into first position. By doing this, we formed a sorted part (formed by the first and second elements of the array), and an unsorted part (formed by the rest elements of the array). Then we compare the first element in the unsorted part with elements within the sorted part until find a suitable position to insert it. And after we successful insert it, we will have a larger sorted part and a smaller unsorted part. By doing these steps once and once again, we will finally get a sorted array.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">10</span>;                                                  <span class="comment">//set arr size=10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[n]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        insertion_sort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;               <span class="comment">//i=the to be inserted element's index</span></span><br><span class="line">                <span class="keyword">int</span> key=arr[i];          <span class="comment">//key=value of the to be inserted element</span></span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;key&lt;arr[j];j--)         <span class="comment">//find the proper position</span></span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];    <span class="comment">//move one position down for insertion</span></span><br><span class="line">                arr[j+<span class="number">1</span>]=key;  <span class="comment">//put the to be inserted element at proper position</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The time complexity of this algorithm in best, average and worst cases are ${\rm O}\left( n \right)$, ${\rm O}\left( { {n^2} } \right)$, ${\rm O}\left( { {n^2} } \right)$ respectively. Thus, it is impractical to use this algorithm for sorting large arrays. However, this Insertion Sort is one of the fastest algorithms for sorting very small arrays, even faster than some more advanced algorithms. Meanwhile, this is an in-place algorithm, and it only needs ${\rm O}\left( {\rm{1} } \right) $ auxiliary storage. It is also a stable algorithm. In practice, it is more efficient than Selection Sort, since when the elements in an array has almost sorted, it has much less work to do compared with Selection Sort.</p>
<h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><p>Merge sort is a much sophisticated sorting algorithm which can be practiced in a paradigm called divide-and-conquer. In a parallel view (human minds), we first divide the array into two smaller arrays, then divide each of the smaller array into another two even smaller arrays, and repeat this process again and again until it cannot be divided any more (all arrays contain one element only). After this, we conquer each pair of the small arrays into a larger array which has exactly the same elements from those two small arrays, but whose order has been rearranged. By repeating these conquer steps again and again, finally there will be left only one array that has the same elements compared with the original one, but who has been sorted. However, in most computers, we cannot manipulate these divide or conquer steps parallel, instead, we will achieve them one by one in a specific order.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[],<span class="keyword">int</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">10</span>;                                                  <span class="comment">//set arr size=10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[n]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> reg[n]=&#123;&#125;;                                          <span class="comment">//deposit elements</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        merge_sort(arr,reg,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> reg[],<span class="keyword">int</span> head,<span class="keyword">int</span> tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head&gt;=tail) <span class="keyword">return</span>;            <span class="comment">//one element in the array, it is sorted</span></span><br><span class="line">        <span class="keyword">int</span> mid=(head+tail)/<span class="number">2</span>;</span><br><span class="line">        merge_sort(arr,reg,head,mid);            <span class="comment">//sort front half of head to tail</span></span><br><span class="line">        merge_sort(arr,reg,mid+<span class="number">1</span>,tail);           <span class="comment">//sort rear half of head to tail</span></span><br><span class="line">        <span class="keyword">int</span> i=head,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=head;k&lt;=tail;k++)     <span class="comment">//by order, copy front &amp; rear halfs to reg</span></span><br><span class="line">                reg[k]= (i&lt;=mid&amp;&amp;(j&gt;tail||arr[i]&lt;=arr[j])) ? arr[i++] : arr[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=head;k&lt;=tail;k++)              <span class="comment">//copy those elements back to arr</span></span><br><span class="line">                arr[k]=reg[k];                        <span class="comment">//now head to tail is sorted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The time complexity of this algorithm in best, average and worst cases are all ${\rm O}\left( {n\log n} \right)$, so it is much faster than all the algorithms we mentioned above. Meanwhile, merge sort is a stable algorithm. But it is not an in-place algorithm and it needs ${\rm O}\left( n \right)$ auxiliary storage. In addition, merge sort is the best choice for sorting a linked list (in this situation it only needs ${\rm O}\left( 1 \right)$ auxiliary storage), while other algorithms (such as quicksort) perform poorly because of the slow access to a random node.</p>
<h1 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h1><p>Quicksort is an efficient and commonly used sorting algorithm, which can also be practiced in the paradigm of divide-and-conquer. In a parallel view (human minds), we first choose an element within the array as a pivot (since we haven’t figure out how to choose a good pivot, we will directly set the last element as a pivot), then we rearrange the position of this pivot, and make sure left of this pivot are all elements smaller than it, while right of this pivot are all elements larger than it (called partition). After finishing this, we divide this array into two smaller arrays (leave alone the pivot). One consists of all the elements smaller than the pivot, and the other one consists of all the elements larger than the piovt. The pivot, however, has been sorted (at the right position). By repeating those steps to these two newly formed arrays parallel, it will end up with an appearance of $n$ arrays ($n$ is the number of elements to be sorted), each of them consists only one element (a pivot). So at the end we will obtain a sorted array. However, in most computers, we cannot manipulate these divide or conquer steps parallel, instead, we will achieve them one by one in a specific order.</p>
<p>Unfortunately, sometimes partitions may be extremely unbalanced (as long as the pivot we chosen is the smallest or largest element in the array) (or all the elements are equal, specially in in Lomuto partition). An extremely unbalanced partition is the last thing we want, and the following formulas explained this.</p>
<p>Let  $T\left( n \right)$ be the time consumption of this algorithm. Ideally, if each time we obtain a perfectly balanced partition:</p>
<p>$$T\left( n \right) = {\rm{O} }\left( n \right) + 2T\left( {\frac{n}{2} } \right){\rm{     } } \Rightarrow {\rm{     } }T\left( n \right) = {\rm{O} }\left( {n\log n} \right)$$</p>
<p>However, if each time we obtain an extremely unbalanced partition:</p>
<p>$$T\left( n \right) = {\rm{O} }\left( n \right) + T\left( {n - 1} \right){\rm{     } } \Rightarrow {\rm{     } }T\left( n \right) = {\rm{O} }\left( { {n^2} } \right)$$</p>
<p>So now there are remaining three things we need to consider:</p>
<ol>
<li>how can we choice a better pivot to improve the occurrence rate of balanced partition sizes.</li>
<li>how can we rearrange all the elements so that left of the pivot are all elements smaller than it, and right of the pivot are all elements larger than it.</li>
<li>how can we improve the performance of our quicksort </li>
</ol>
<p><strong>Median-of-Three</strong> is a simply solution to find an approximately median as the pivot, which will lead to an approximately balanced partition. Although its partition is not so perfect, median-of-three has great advantage in speed. Unlike it takes ${\rm O}\left( n \right)$ time to find the real median for creating a perfectly balanced partition, mid-of-three only needs ${\rm O}\left( 1 \right)$ time. After testing, we find a quicksort applies median-of-three method is much faster then the one finding the real median.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid=(head+tail)/<span class="number">2</span>;                                   <span class="comment">//be cautious of overflow</span></span><br><span class="line"><span class="keyword">if</span>(arr[mid]&lt;arr[head]) swap(arr[head],arr[mid]);        <span class="comment">//if array size &gt;= 3, then</span></span><br><span class="line"><span class="keyword">if</span>(arr[tail]&lt;arr[head]) swap(arr[head],arr[tail]);     <span class="comment">//the smallest in arr[head]</span></span><br><span class="line"><span class="keyword">if</span>(arr[mid]&lt;arr[tail]) swap(arr[mid],arr[tail]);    <span class="comment">//median of three in arr[tail]</span></span><br></pre></td></tr></table></figure>
<p><strong>Lomuto Partition</strong> is a partition scheme detailedly mentioned in the book <em>Introduction to Algorithms</em>, and it is widely used in teaching, although it is less efficient than Hoare partition (and it performs awfully when the number of repeated elements increases).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">10</span>;                                                  <span class="comment">//set arr size=10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[n]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        quicksort(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> head,<span class="keyword">int</span> tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head&gt;=tail) <span class="keyword">return</span>;            <span class="comment">//one element in the array, it is sorted</span></span><br><span class="line">        <span class="keyword">int</span> mid=(head+tail)/<span class="number">2</span>;   <span class="comment">//set arr[tail] (pivot) to be the median of three</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;arr[head]) swap(arr[head],arr[mid]);</span><br><span class="line">        <span class="keyword">if</span>(arr[tail]&lt;arr[head]) swap(arr[head],arr[tail]);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;arr[tail]) swap(arr[mid],arr[tail]);</span><br><span class="line">        <span class="keyword">int</span> k=head;                        <span class="comment">//partition all elements into two parts</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head;i&lt;tail;i++)                       <span class="comment">//(leave alone the pivot)</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i]&lt;arr[tail]) swap(arr[k++],arr[i]);</span><br><span class="line">        swap(arr[k],arr[tail]);                                   <span class="comment">//sort the pivot</span></span><br><span class="line">        quicksort(arr,head,k<span class="number">-1</span>);                 <span class="comment">//sort the left part of the pivot</span></span><br><span class="line">        quicksort(arr,k+<span class="number">1</span>,tail);                <span class="comment">//sort the right part of the pivot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hoare Partition</strong> is a much more efficient partition scheme, as it does three times fewer swaps on average (and it performs good when there are many repeated elements, even when all values are equal, it creates efficient partitions). </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">10</span>;                                                  <span class="comment">//set arr size=10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[n]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        quicksort(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> head,<span class="keyword">int</span> tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head&gt;=tail) <span class="keyword">return</span>;            <span class="comment">//one element in the array, it is sorted</span></span><br><span class="line">        <span class="keyword">int</span> mid=(head+tail)/<span class="number">2</span>;   <span class="comment">//set arr[tail] (pivot) to be the median of three</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;arr[head]) swap(arr[head],arr[mid]);</span><br><span class="line">        <span class="keyword">if</span>(arr[tail]&lt;arr[head]) swap(arr[head],arr[tail]);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;arr[tail]) swap(arr[mid],arr[tail]);</span><br><span class="line">        <span class="keyword">int</span> i=head<span class="number">-1</span>,j=tail;               <span class="comment">//partition all elements into two parts</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;                                        <span class="comment">//(leave alone the pivot)</span></span><br><span class="line">                <span class="keyword">do</span> i++; <span class="keyword">while</span>(arr[i]&lt;arr[tail]);</span><br><span class="line">                <span class="keyword">do</span> j--; <span class="keyword">while</span>(arr[j]&gt;arr[tail]);</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">                swap(arr[i],arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i],arr[tail]);                                   <span class="comment">//sort the pivot</span></span><br><span class="line">        quicksort(arr,head,i<span class="number">-1</span>);                 <span class="comment">//sort the left part of the pivot</span></span><br><span class="line">        quicksort(arr,i+<span class="number">1</span>,tail);                <span class="comment">//sort the right part of the pivot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Farther Optimizations</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Comparison-Sorts/" rel="tag"><i class="fa fa-tag"></i> Comparison Sorts</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/27/Primality Testing/" rel="next" title="Primality Testing">
                <i class="fa fa-chevron-left"></i> Primality Testing
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/03/Lists, Stacks and Queues (MTL)/" rel="prev" title="Lists, Stacks and Queues (MTL)">
                Lists, Stacks and Queues (MTL) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Xu Jiayun</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            


            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            


          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/OSCAR-XJY" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:X1069505992@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          



          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Description"><span class="nav-number">1.</span> <span class="nav-text">Description</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bubble-Sort"><span class="nav-number">2.</span> <span class="nav-text">Bubble Sort</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Selection-Sort"><span class="nav-number">3.</span> <span class="nav-text">Selection Sort</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Insertion-Sort"><span class="nav-number">4.</span> <span class="nav-text">Insertion Sort</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Merge-Sort"><span class="nav-number">5.</span> <span class="nav-text">Merge Sort</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Quicksort"><span class="nav-number">6.</span> <span class="nav-text">Quicksort</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Jiayun</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/love.js"></script>